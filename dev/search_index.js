var documenterSearchIndex = {"docs":
[{"location":"gettingstarted/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"gettingstarted/#Usage","page":"Getting Started","title":"Usage","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using Transits\n\norbit = SimpleOrbit(period=3, duration=1)\nu = [0.4, 0.26] # quad limb dark\nld = PolynomialLimbDark(u)\n\nt = range(-1, 1, length=1000) # days from t0\nrs = range(0, 0.2, length=10) # radius ratio\n\nfluxes = @. ld(orbit, t, rs')","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"gettingstarted/#Integrated-and-Secondary-Curves","page":"Getting Started","title":"Integrated and Secondary Curves","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"IntegratedLimbDark can be used to numerically integrate each light curve exposure in time","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"ld = IntegratedLimbDark([0.4, 0.26])\norbit = SimpleOrbit(period=3, duration=1)\nt = range(-1, 1, length=1000)\ntexp = [0.1 0.2 0.3]\n# no extra calculations made\nflux = @. ld(orbit, t, 0.2)\n# use quadrature to find time-averaged flux for each t\nflux_int = @. ld(orbit, t, 0.2, texp) ","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"SecondaryLimbDark can be used to generate secondary eclipses given a surface brightness ratio","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"ld = SecondaryLimbDark([0.4, 0.26], brightness_ratio=0.1)\nld_int = IntegratedLimbDark(ld) # composition works flawlessly\n\norbit = SimpleOrbit(period=4, duration=1)\nt = range(-1.25, 2.75, length=1000)\nrs = range(0.01, 0.1, length=6)\n\nf = @. ld(orbit, t, rs')\nf_int = @. ld_int(orbit, t, rs', texp=0.3)","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"(Image: )","category":"page"},{"location":"gettingstarted/#Using-Units","page":"Getting Started","title":"Using Units","text":"","category":"section"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"Units from Unitful.jl are a drop-in substitution for numbers","category":"page"},{"location":"gettingstarted/","page":"Getting Started","title":"Getting Started","text":"using Unitful\norbit = SimpleOrbit(period=10u\"d\", duration=5u\"hr\")\nt = range(-6, 6, length=1000)u\"hr\"\nflux = @. ld(orbit, t, 0.1)","category":"page"},{"location":"api/#API/Reference","page":"API/Reference","title":"API/Reference","text":"","category":"section"},{"location":"api/#Index","page":"API/Reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"","category":"page"},{"location":"api/#API/Reference-2","page":"API/Reference","title":"API/Reference","text":"","category":"section"},{"location":"api/","page":"API/Reference","title":"API/Reference","text":"Modules = [Transits, Transits.Orbits]","category":"page"},{"location":"api/#Transits.IntegratedLimbDark-Tuple{AbstractLimbDark}","page":"API/Reference","title":"Transits.IntegratedLimbDark","text":"IntegratedLimbDark(limbdark; N=21, basis=:legendre)\nIntegratedLimbDark(u; kwargs...)\n\nComputes the time-averaged flux in the middle of an exposure by wrapping a limb darkening law limbdark with a quadrature scheme. For each time step t, N extra points are super-sampled from t-texp/2 to t+texp/2and the time-averaged flux is calculated via quadrature.\n\nIf a set of limb darkening coefficients, u, is provided, a PolynomialLimbDark law will be used by default.\n\nMathematical form\n\nbarF(t) = frac1Delta tint_t-Delta t  2^t+Delta t  2F(t)dt\n\nwhere F is the wrapped limb darkening law and Delta t is the exposure time.\n\nQuadrature\n\nThe integration is approximated via Guassian quadrature\n\nfrac1Delta t intF(t)dt approx frac12sum_i^Nw_i * F(fracDelta t2xi_i + t)\n\nwhere the weights w_i and nodes ξ_i are defined by the given quadrature rule. The nodes are defined by evaluating orthogonal polynomials N times between -1 and 1. Notice the change of interval required to go from the natural bounds of the orthogonal polynomial basis, -1, 1, to the range defined by the exposure time.\n\nThe following bases are available from FastGaussQuadrature.jl. In addition, a function can be passed which calculates nodes, weights = f(N).\n\n:legendre - Legendre polynomial base on the open (-1, 1)\n:radau - Legendre polynomial base on the semi-open [-1, 1) interval\n:lobatto - Legendre polynomial base on the closed [-1, 1] interval\n\n\n\n\n\n","category":"method"},{"location":"api/#Transits.PolynomialLimbDark-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T","page":"API/Reference","title":"Transits.PolynomialLimbDark","text":"PolynomialLimbDark(u::AbstractVector)\n\nPolynomial limb darkening using analytical integrals. The length of the u vector is equivalent to the order of polynomial used; e.g., [0.2, 0.3] corresponds to quadratic limb darkening.\n\nMathematical form\n\nI(mu) propto 1 - u_1(1-mu) - u_2(1-mu)^2 - dots - u_N(1-mu)^N\n\nwhich is equivalent to the series\n\nI(mu) propto -sum_i=0^Nu_i(1-mu)^i\n\nwith the definition u_0 equiv -1.\n\n\n\n\n\n","category":"method"},{"location":"api/#Transits.SecondaryLimbDark-Tuple{AbstractLimbDark,AbstractLimbDark}","page":"API/Reference","title":"Transits.SecondaryLimbDark","text":"\n\n\n\n","category":"method"},{"location":"api/#Transits.compute_Mn_coeffs!-Union{Tuple{T}, Tuple{AbstractArray{T,3},Any}} where T","page":"API/Reference","title":"Transits.compute_Mn_coeffs!","text":"Compute the series expandsion coefficients for the M_n integrals. Need to compute from n_max - 3:n_max. Also split for the cases k^2 < 1 and k^2 ≥ 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#Transits.compute_Nn_coeffs!-Union{Tuple{T}, Tuple{AbstractArray{T,2},Any}} where T","page":"API/Reference","title":"Transits.compute_Nn_coeffs!","text":"Compute the series expandsion coefficients for the N_n integrals. Need to compute from n_max - 3:n_max. Only need the case k^2 < 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#Transits.compute_gn-Tuple{AbstractArray{T,1} where T}","page":"API/Reference","title":"Transits.compute_gn","text":"Transform the u_n coefficients to g_n, which are coefficients in Green's basis from REF.\n\n\n\n\n\n","category":"method"},{"location":"api/#Transits.Orbits.SimpleOrbit-Tuple{}","page":"API/Reference","title":"Transits.Orbits.SimpleOrbit","text":"SimpleOrbit(; period, duration, t0=0, b=0, r_star=1)\n\nCircular orbit parameterized by the basic observables of a transiting system.\n\nParameters\n\nperiod - The orbital period of the planets, nominally in days\nduration The duration of the transit, same units as period\nt0 - The midpoint time of the reference transit, same units as period\nb - The impact parameter of the orbit\nr_star - The radius of the star, nominally in solar radii\n\n\n\n\n\n","category":"method"},{"location":"api/#Transits.Orbits.relative_position-Tuple{Transits.Orbits.AbstractOrbit,Any}","page":"API/Reference","title":"Transits.Orbits.relative_position","text":"relative_position(::AbstractOrbit, t)\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Transits","category":"page"},{"location":"#Transits.jl","page":"Home","title":"Transits.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: GitHub) (Image: Build Status) (Image: Coverage) (Image: License)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Transits.jl provides flexible and powerful occultation curves with limb darkening. The goals of this package are, in this order","category":"page"},{"location":"","page":"Home","title":"Home","text":"have a simple interface with high compasibility\nbe as flexible with respect to numeric types and application\nbe fully compatible with ChainRules.jl automatic differentiation (AD) system to leverage the derived analytical gradients\nprovide a code-base that is well-organized, instructive, and easy to extend\nmaintain high performance: at least as fast as similar tools","category":"page"},{"location":"","page":"Home","title":"Home","text":"In particular, PolynomialLimbDark implements the \"starry\" limb darkening method, which solves the flux integral analytically. This provides floating-point errors and runtimes that are best in class.","category":"page"}]
}
